// This file is a part of the NICA project.
//
// Copyright (C) 2023 JINR

// This largely duplicates the statistics generated by
// ActsExamples::CKFPerformanceWriter. This is done in
// order to manually write performance of the tracking
// and further use such functions for the current tracker,
// used in MpdRoot. For comparison.

#include "MpdTpcEventData.h"
#include "MpdTpcInputHit.h"
#include "PerfUtils.h"

#include <TFile.h>
#include <TH1.h>
#include <TVector3.h>

#include <algorithm>
#include <iostream>
#include <fstream>

// Dump trackIds to file.
void uploadTrackIds(
    const std::vector<Int_t> &trackIds,
    Int_t eventNumber,
    std::string path) {
  auto fname = path + "/"
      "event_" + std::to_string(eventNumber) + "_trackIds.txt";
  std::ofstream fout(fname);
  for (auto trackId : trackIds) {
    fout << trackId << std::endl;
  }
}

// Read trackIds from file
std::vector<Int_t> downloadTrackIds(
    Int_t eventNumber,
    std::string path) {
  std::string fname = path + "/"
        "event_" + std::to_string(eventNumber) + "_trackIds.txt";
  std::ifstream f(fname);
  std::vector<Int_t> result;
  std::string prefix = "downloadTrackIds(): ";
  if (!f.good()) {
    std::cout << prefix << "Cannot open file " << fname << std::endl;
    return result;
  }
  std::string prefixErr = prefix + "error while converting string to int: ";
  std::string line;
  if (f.is_open()){
    while (getline(f, line)) {
      Bool_t success = true;
      Int_t trackId;
      try {
        trackId = std::stoi(line);
      } catch (std::invalid_argument const& ex) {
        std::cout << prefixErr << ex.what() << std::endl;
        success = false;
      } catch (std::out_of_range const& ex) {
        std::cout << prefixErr << ex.what() << std::endl;
        success = false;
      } catch (...) {
        std::cout << prefixErr << "Unknown error" << std::endl;
        success = false;
      }
      if (success) {
        result.push_back(trackId);
      }
    }
  } else {
    std::cout << prefix + "cannot open " << fname << std::endl;
  }
  return result;
}

Double_t eta(MpdMCTrack *mcTrack, TVector3 &v) {
  Double_t px = mcTrack->GetPx();
  Double_t py = mcTrack->GetPy();
  Double_t pz = mcTrack->GetPz();

  v.SetX(px);
  v.SetY(py);
  v.SetZ(pz);

  return v.PseudoRapidity();
}

void printEff(const std::map<Int_t, Bool_t> &trackIdToRecoMap,
              std::string prefix) {
  Int_t total = trackIdToRecoMap.size();
  Int_t passed = 0;
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    if (isReco) {
      passed++;
    }
  }
  Double_t eff = total == 0 ? 0 : 1.*passed / total;
  std::cout << prefix << " efficiency: " <<
      passed << " / " << total << " = " << eff << std::endl;
}

void printEff(std::string prefix,
              TEfficiency *tEff) {
  const TH1 *passedH = tEff->GetPassedHistogram();
  const TH1 *totalH  = tEff->GetTotalHistogram();

  Int_t nBins = passedH->GetNbinsX();
  Double_t passed = 0;
  Double_t total  = 0;

  for (size_t i = 1; i <= nBins; i++) {
     passed += passedH->GetBinContent(i);
     total  += totalH-> GetBinContent(i);
  }
  Double_t eff = total == 0 ? 0 : passed / total;

  std::cout << prefix << passed << " / " << total << " = " << eff << std::endl;
}

void updateTEffPt(const std::map<Int_t, Bool_t> &trackIdToRecoMap,
                  TEfficiency *eff,
                  TClonesArray *mcTracks) {
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    auto mcTrack = static_cast<MpdMCTrack*>(mcTracks->UncheckedAt(trackId));
    Double_t val = mcTrack->GetPt();
    eff->Fill(isReco, val);
  }
}

void updateTEffEta(const std::map<Int_t, Bool_t> &trackIdToRecoMap,
                               TEfficiency *eff,
                               TClonesArray *mcTracks) {
  TVector3 v;
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    auto mcTrack = static_cast<MpdMCTrack*>(mcTracks->UncheckedAt(trackId));
    Double_t val = eta(mcTrack, v);
    eff->Fill(isReco, val);
  }
}

void saveToRoot(TEfficiency *effPt,
                TEfficiency *effEta,
                std::string fname) {
  TFile f(fname.c_str(), "update");
  effPt->Write();
  effEta->Write();
  f.Close();
}

Int_t calcMajTrackId(const Mpd::Tpc::ProtoTrack &track,
                     const Mpd::Tpc::InputHitContainer &hits) {
  std::map<Int_t, Int_t> trackIdToNHitsMap;

  for (Int_t ihit : track) {
    auto hit = hits.at(ihit);
    Int_t trackId = hit.trackId;
    trackIdToNHitsMap[trackId] += 1;
  }
  Int_t maxHits = 0;
  Int_t majTackId;
  for (auto &[trackId, nhits] : trackIdToNHitsMap) {
    if (nhits > maxHits) {
      maxHits = nhits;
      majTackId = trackId;
    }
  }
  return majTackId;
}

Double_t truthProb(const Mpd::Tpc::ProtoTrack &track,
                   const Mpd::Tpc::InputHitContainer &hits,
                   Int_t majTrackId) {
  Int_t subTrackLen = 0;
  Int_t len = track.size();
  for (Int_t ihit : track) {
    auto hit = hits.at(ihit);
    if (hit.trackId == majTrackId) {
      subTrackLen++;
    }
  }
  return (len == 0) ? 0 : 1.*subTrackLen / len;
}

Bool_t evalIsReco(const Mpd::Tpc::ProtoTrack &track,
                  const Mpd::Tpc::InputHitContainer &hits,
                  Int_t majTrackId,
                  Int_t measurementsMin,
                  Double_t truthMatchProbMin) {
  return
      (track.size() >= measurementsMin) &&
      (truthProb(track, hits, majTrackId) >= truthMatchProbMin);
}

std::unordered_map<Int_t, Mpd::Tpc::ProtoTrack> calcRealTracks(
    const Mpd::Tpc::InputHitContainer &hits) {
  std::unordered_map<Int_t, Mpd::Tpc::ProtoTrack> tracks;
  tracks.reserve(hits.size());

  size_t ihit = 0;
  for (const auto &hit : hits) {
    tracks[hit.trackId].push_back(ihit++);
  }
  return tracks;
}

std::tuple<Int_t, Int_t, Int_t> changeTotalNFake(
    std::map<Int_t, std::pair<Int_t, Int_t>> trackIdToTruthFakeMap,
    Int_t &nTruthT,
    Int_t &nFakeT,
    Int_t &nRealTracksT) {
  Int_t nTruth      = 0;
  Int_t nFake       = 0;
  Int_t nRealTracks = 0;
  for (auto &[trackId, truthFakePair] : trackIdToTruthFakeMap) {
    nTruth += truthFakePair.first;
    nFake  += truthFakePair.second;
    nRealTracks++;
  }
  nTruthT      += nTruth;
  nFakeT       += nFake;
  nRealTracksT += nRealTracks;
  return std::make_tuple(nTruth, nFake, nRealTracks);
}

void printFake(Int_t nTruth,
               Int_t nFake,
               Int_t nRealTracks,
               std::string prefix) {
  std::cout << prefix << std::endl <<
      "    truth track candidates:" << nTruth                 << std::endl <<
      "    fake track candidates: " << nFake                  << std::endl <<
      "    n real tracks:         " << nRealTracks            << std::endl <<
      "    fake / real:           " << 1.*nFake / nRealTracks << std::endl <<
      "    fake / truth:          " << 1.*nFake / nTruth      << std::endl;
}

void runPerformance(
    TEfficiency *effPt,
    TEfficiency *effEta,
    Int_t &nTruthT,
    Int_t &nFakeT,
    Int_t &nRealTracksT,
    std::string inPath,
    std::string outPath,
    Int_t eventNumber,
    const Mpd::Tpc::ProtoTrackContainer &trajectories,
    const Mpd::Tpc::InputHitContainer &hits,
    TClonesArray *mcTracks,
    Int_t measurementsMin,
    Double_t truthMatchProbMin,
    Bool_t onlySelectedTracks,
    std::string outFile) {
  auto trackIds = downloadTrackIds(eventNumber, inPath);
  std::map<Int_t, Bool_t> trackIdToRecoMap;

  // trackId -> (the number of truth reco, the number of fake tracks)
  std::map<Int_t, std::pair<Int_t, Int_t>> trackIdToTruthFakeMap;

  auto realTracks = calcRealTracks(hits);

  // Initialize map trackId -> IsReco to false.
  for (auto &[trackId, hitsV] : realTracks) {
    Bool_t trackIsSelected = true;
    if (onlySelectedTracks &&
        (std::find(trackIds.begin(), trackIds.end(), trackId) ==
         trackIds.end())) {
      trackIsSelected = false;
    }

    Bool_t lenOk = (hitsV.size() >= measurementsMin);
    Bool_t needStoreTrack = trackIsSelected && lenOk;
    if (needStoreTrack) {
      trackIdToRecoMap[trackId] = false;
      trackIdToTruthFakeMap[trackId] = std::make_pair(0, 0);
    }
  }

  for (auto track : trajectories) {
    Int_t majTrackId = calcMajTrackId(track, hits);

    // Skip not selected tracks if needed.
    if (onlySelectedTracks &&
        (std::find(trackIds.begin(),
                   trackIds.end(), majTrackId) == trackIds.end())) {
      continue;
    }
    // Skip short tracks.
    if (track.size() < measurementsMin) {
      continue;
    }
    Bool_t isReco =
        evalIsReco(track, hits, majTrackId, measurementsMin, truthMatchProbMin);
    trackIdToRecoMap[majTrackId] = trackIdToRecoMap[majTrackId] || isReco;

    if (isReco) {
      trackIdToTruthFakeMap[majTrackId].first++;
    } else {
      trackIdToTruthFakeMap[majTrackId].second++;
    }
  }

  printEff(trackIdToRecoMap,
      "local efficiency for event " + std::to_string(eventNumber) + ": ");

  updateTEffPt(trackIdToRecoMap,
               effPt,
               mcTracks);

  updateTEffEta(trackIdToRecoMap,
                effEta,
                mcTracks);

  printEff("Total efficiency (effPt): ",  effPt);
  printEff("Total efficiency (effEta): ", effEta);

  auto [nTruth, nFake, nRealTracks] =
      changeTotalNFake(trackIdToTruthFakeMap, nTruthT, nFakeT, nRealTracksT);
  printFake(nTruth, nFake, nRealTracks,
      "Fake stat for event: " + std::to_string(eventNumber));
  printFake(nTruthT, nFakeT, nRealTracksT,
      "Fake stat for all events: ");

  saveToRoot(effPt, effEta, outPath + "/" + outFile);
}

