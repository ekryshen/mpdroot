// This file is a part of the NICA project.
//
// Copyright (C) 2023 JINR

// This largely duplicates the statistics generated by
// ActsExamples::CKFPerformanceWriter. This is done in
// order to manually write performance of the tracking
// and further use such functions for the current tracker,
// used in MpdRoot. For comparison.

#include "MpdTpcEventData.h"
#include "MpdTpcInputHit.h"
#include "PerfUtils.h"

#include <TFile.h>
#include <TH1.h>
#include <TVector3.h>

#include <algorithm>
#include <iostream>
#include <fstream>

// Dump trackIds to file.
void uploadTrackIds(const std::vector<Int_t> &trackIds,
                    Int_t eventNumber,
                    std::string path) {
  auto fname = path + "/"
      "event_" + std::to_string(eventNumber) + "_trackIds.txt";
  std::ofstream fout(fname);
  for (auto trackId : trackIds) {
    fout << trackId << std::endl;
  }
}

// Read trackIds from file
std::vector<Int_t> downloadTrackIds(Int_t eventNumber,
                                    std::string path) {
  std::string fname = path + "/"
        "event_" + std::to_string(eventNumber) + "_trackIds.txt";
  std::ifstream f(fname);
  std::vector<Int_t> result;
  std::string prefix = "downloadTrackIds(): ";
  if (!f.good()) {
    std::cout << prefix << "Cannot open file " << fname << std::endl;
    return result;
  }
  std::string prefixErr = prefix + "error while converting string to int: ";
  std::string line;
  if (f.is_open()){
    while (getline(f, line)) {
      Bool_t success = true;
      Int_t trackId;
      try {
        trackId = std::stoi(line);
      } catch (std::invalid_argument const& ex) {
        std::cout << prefixErr << ex.what() << std::endl;
        success = false;
      } catch (std::out_of_range const& ex) {
        std::cout << prefixErr << ex.what() << std::endl;
        success = false;
      } catch (...) {
        std::cout << prefixErr << "Unknown error" << std::endl;
        success = false;
      }
      if (success) {
        result.push_back(trackId);
      }
    }
  } else {
    std::cout << prefix + "cannot open " << fname << std::endl;
  }
  return result;
}

Double_t eta(MpdMCTrack *mcTrack, TVector3 &v) {
  Double_t px = mcTrack->GetPx();
  Double_t py = mcTrack->GetPy();
  Double_t pz = mcTrack->GetPz();

  v.SetX(px);
  v.SetY(py);
  v.SetZ(pz);

  return v.PseudoRapidity();
}

/// Calculates and prints efficiency based on TEfficiency object.
void printEfficiency(std::string prefix,
                     TEfficiency *tEff) {
  const TH1 *passedH = tEff->GetPassedHistogram();
  const TH1 *totalH  = tEff->GetTotalHistogram();

  Int_t nBins = passedH->GetNbinsX();
  Double_t passed = 0;
  Double_t total  = 0;

  for (size_t i = 1; i <= nBins; i++) {
     passed += passedH->GetBinContent(i);
     total  += totalH-> GetBinContent(i);
  }
  Double_t eff = total == 0 ? 0 : passed / total;

  std::cout << prefix << passed << " / " << total << " = " << eff << std::endl;
}

/// Calculates and prints efficiency based on map trackId -> isReco.
void printEfficiency(std::string prefix,
                     const std::map<Int_t, Bool_t> &trackIdToRecoMap) {
  Int_t total = trackIdToRecoMap.size();
  Int_t passed = 0;
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    if (isReco) {
      passed++;
    }
  }
  Double_t eff = total == 0 ? 0 : 1.*passed / total;
  std::cout << prefix <<
      passed << " / " << total << " = " << eff << std::endl;
}

/// Calculates and prints total efficiency based on
/// map trackId -> (n truth prototracks, n fake prototracks).
void printEfficiency(
    std::string prefix,
    const std::map<Int_t, std::pair<Int_t, Int_t>> &trackIdToTruthFakeMap) {
  size_t nReco = 0;
  for (auto [trackId, truthFakePair] : trackIdToTruthFakeMap) {
    Bool_t isReco = (truthFakePair.first == 0) ? false : true;
    if (isReco) {
      nReco++;
    }
  }
  static size_t nRecoG = 0;
  nRecoG += nReco;
  static size_t nTotalG = 0;
  nTotalG += trackIdToTruthFakeMap.size();
  Double_t eff = nTotalG == 0 ? 0 : 1. * nRecoG / nTotalG;
  std::cout << prefix <<
      nRecoG << " / " << nTotalG << " = " << eff << std::endl;
}

void updateTEffPt(const std::map<Int_t, Bool_t> &trackIdToRecoMap,
                  TEfficiency *eff,
                  TClonesArray *mcTracks) {
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    auto mcTrack = static_cast<MpdMCTrack*>(mcTracks->UncheckedAt(trackId));
    Double_t val = mcTrack->GetPt();
    eff->Fill(isReco, val);
  }
}

void updateTEffEta(const std::map<Int_t, Bool_t> &trackIdToRecoMap,
                   TEfficiency *eff,
                   TClonesArray *mcTracks) {
  TVector3 v;
  for (auto &[trackId, isReco] : trackIdToRecoMap) {
    auto mcTrack = static_cast<MpdMCTrack*>(mcTracks->UncheckedAt(trackId));
    Double_t val = eta(mcTrack, v);
    eff->Fill(isReco, val);
  }
}

void saveToRoot(TEfficiency *effPt,
                TEfficiency *effEta,
                std::string fname) {
  TFile f(fname.c_str(), "update");
  effPt->Write();
  effEta->Write();
  f.Close();
}

Int_t calcMajTrackId(const Mpd::Tpc::ProtoTrack &track,
                     const Mpd::Tpc::InputHitContainer &hits) {
  std::map<Int_t, Int_t> trackIdToNHitsMap;

  for (Int_t ihit : track) {
    auto hit = hits.at(ihit);
    Int_t trackId = hit.trackId;
    trackIdToNHitsMap[trackId] += 1;
  }
  Int_t maxHits = 0;
  Int_t majTackId;
  for (auto &[trackId, nhits] : trackIdToNHitsMap) {
    if (nhits > maxHits) {
      maxHits = nhits;
      majTackId = trackId;
    }
  }
  return majTackId;
}

Double_t truthProb(const Mpd::Tpc::ProtoTrack &track,
                   const Mpd::Tpc::InputHitContainer &hits,
                   Int_t majTrackId) {
  Int_t subTrackLen = 0;
  Int_t len = track.size();
  for (Int_t ihit : track) {
    auto hit = hits.at(ihit);
    if (hit.trackId == majTrackId) {
      subTrackLen++;
    }
  }
  return (len == 0) ? 0 : 1.*subTrackLen / len;
}

Bool_t evalIsReco(const Mpd::Tpc::ProtoTrack &track,
                  const Mpd::Tpc::InputHitContainer &hits,
                  Int_t majTrackId,
                  Int_t measurementsMin,
                  Double_t truthMatchProbMin) {
  return
      (track.size() >= measurementsMin) &&
      (truthProb(track, hits, majTrackId) >= truthMatchProbMin);
}

std::unordered_map<Int_t, Mpd::Tpc::ProtoTrack> calcRealTracks(
    const Mpd::Tpc::InputHitContainer &hits) {
  std::unordered_map<Int_t, Mpd::Tpc::ProtoTrack> tracks;
  tracks.reserve(hits.size());

  size_t ihit = 0;
  for (const auto &hit : hits) {
    tracks[hit.trackId].push_back(ihit++);
  }
  return tracks;
}

std::tuple<Int_t, Int_t, Int_t> changeTotalNFake(
    std::map<Int_t, std::pair<Int_t, Int_t>> trackIdToTruthFakeMap,
    Int_t &nTruthT,
    Int_t &nFakeT,
    Int_t &nRealTracksT) {
  Int_t nTruth      = 0;
  Int_t nFake       = 0;
  Int_t nRealTracks = 0;
  for (auto &[trackId, truthFakePair] : trackIdToTruthFakeMap) {
    nTruth += truthFakePair.first;
    nFake  += truthFakePair.second;
    nRealTracks++;
  }
  nTruthT      += nTruth;
  nFakeT       += nFake;
  nRealTracksT += nRealTracks;
  return std::make_tuple(nTruth, nFake, nRealTracks);
}

void printFake(Int_t nTruth,
               Int_t nFake,
               Int_t nRealTracks,
               std::string prefix) {
  std::cout << prefix << std::endl <<
      "    truth track candidates:" << nTruth                 << std::endl <<
      "    fake track candidates: " << nFake                  << std::endl <<
      "    n real tracks:         " << nRealTracks            << std::endl <<
      "    fake / real:           " << 1.*nFake / nRealTracks << std::endl <<
      "    fake / truth:          " << 1.*nFake / nTruth      << std::endl;
}

std::map<Int_t, Bool_t> runPerformance(
    TEfficiency *effPt,
    TEfficiency *effEta,
    Int_t &nTruthT,
    Int_t &nFakeT,
    Int_t &nRealTracksT,
    std::string inPath,
    std::string outPath,
    Int_t eventNumber,
    const Mpd::Tpc::ProtoTrackContainer &trajectories,
    const Mpd::Tpc::InputHitContainer &hits,
    TClonesArray *mcTracks,
    Int_t measurementsMin,
    Double_t truthMatchProbMin,
    Bool_t onlySelectedTracks,
    std::string outFile) {
  auto trackIds = downloadTrackIds(eventNumber, inPath);
  std::map<Int_t, Bool_t> trackIdToRecoMap;

  // trackId -> (the number of truth reco, the number of fake tracks)
  std::map<Int_t, std::pair<Int_t, Int_t>> trackIdToTruthFakeMap;

  auto realTracks = calcRealTracks(hits);

  // Initialize map trackId -> IsReco to false.
  for (auto &[trackId, hitsV] : realTracks) {
    Bool_t trackIsSelected = true;
    if (onlySelectedTracks &&
        (std::find(trackIds.begin(), trackIds.end(), trackId) ==
         trackIds.end())) {
      trackIsSelected = false;
    }

    Bool_t lenOk = (hitsV.size() >= measurementsMin);
    Bool_t needStoreTrack = trackIsSelected && lenOk;
    if (needStoreTrack) {
      trackIdToRecoMap[trackId] = false;
      trackIdToTruthFakeMap[trackId] = std::make_pair(0, 0);
    }
  }

  for (auto track : trajectories) {
    Int_t majTrackId = calcMajTrackId(track, hits);

    // Skip not selected tracks if needed.
    if (onlySelectedTracks &&
        (std::find(trackIds.begin(),
                   trackIds.end(), majTrackId) == trackIds.end())) {
      continue;
    }
    // Skip short tracks.
    if (track.size() < measurementsMin) {
      continue;
    }
    Bool_t isReco =
        evalIsReco(track, hits, majTrackId, measurementsMin, truthMatchProbMin);
    trackIdToRecoMap[majTrackId] = trackIdToRecoMap[majTrackId] || isReco;

    if (isReco) {
      trackIdToTruthFakeMap[majTrackId].first++;
    } else {
      trackIdToTruthFakeMap[majTrackId].second++;
    }
  }
  std::string postfix = "event " + std::to_string(eventNumber) + ": ";
  printEfficiency("Local efficiency "  + postfix, trackIdToRecoMap);

  updateTEffPt(trackIdToRecoMap,
               effPt,
               mcTracks);

  updateTEffEta(trackIdToRecoMap,
                effEta,
                mcTracks);

  std::string prefix  = "Total efficiency ";
  printEfficiency(prefix + "(effPt) "  + postfix, effPt);
  printEfficiency(prefix + "(effEta) " + postfix, effEta);
  printEfficiency(prefix + "(nReco) "  + postfix, trackIdToTruthFakeMap);

  auto [nTruth, nFake, nRealTracks] =
      changeTotalNFake(trackIdToTruthFakeMap, nTruthT, nFakeT, nRealTracksT);
  printFake(nTruth, nFake, nRealTracks,
      "Fake stat for event: " + std::to_string(eventNumber));
  printFake(nTruthT, nFakeT, nRealTracksT,
      "Fake stat for all events: ");

  saveToRoot(effPt, effEta, outPath + "/" + outFile);
  return trackIdToRecoMap;
}

/// Prints information about MC tracks based on
/// MC inforation, also whether track is reconstructed and some others.
void printMcTracks(
    TClonesArray *mcTracks,
    const std::set<Int_t> &trackIds,
    const Mpd::Tpc::InputHitContainer &hits,        // all hits. Not selected
    const std::map<size_t, ActsFatras::Barcode> &trackIdToBarcodeMap,
    Bool_t printReco,
    const std::map<Int_t, Bool_t> &trackIdToRecoMap,
    std::string prefix,
    Bool_t allTracks) {
  std::map<Int_t, Int_t> trackIdToNhits;

  Int_t nMcTracks = mcTracks->GetEntriesFast();
  for (size_t trackId = 0; trackId < nMcTracks; trackId++) {
    trackIdToNhits[trackId] = 0;
  }
  Int_t ihit = -1;
  for (const auto &hit : hits) {
    ihit++;
    Int_t trackId = hit.trackId;
    if (trackIdToNhits.find(trackId) == trackIdToNhits.end()) {
      std::cout << "printMcTracks(): "
          "unknown trackId " << trackId << " "
          "for hit #"        << ihit    <<
          std::endl;
      trackIdToNhits[trackId] = 0;
    }
    trackIdToNhits.at(trackId)++;
  }

  size_t counter = 0;
  for (size_t trackId = 0; trackId < nMcTracks; trackId++) {
    auto mcTrack = static_cast<MpdMCTrack*>(mcTracks->UncheckedAt(trackId));
    if (!allTracks) {
      if (trackIds.find(trackId) == trackIds.end()) {
        continue;
      }
    }
    ActsFatras::Barcode barcode;
    auto findBarcode = trackIdToBarcodeMap.find(trackId);
    std::string localPrefix;
    if (findBarcode == trackIdToBarcodeMap.end()) {
       localPrefix = prefix +
           std::string("can't find barcode for trackId ") +
           std::to_string(trackId) + "\n";
       barcode = ActsFatras::Barcode();
    } else {
      barcode = findBarcode->second;
    }

    TVector3 v;

    std::cout << localPrefix;
    std::cout << prefix     <<
        "#"                 << counter++              << "; " <<
        "MC info: {"        <<
        "trackId: "         << trackId                << "; " <<
        "motherId: "        << mcTrack->GetMotherId() << "; " <<
        "p: "               << mcTrack->GetP()        << "; " <<
        "pt: "              << mcTrack->GetPt()       << "; " <<
        "pdg: "             << mcTrack->GetPdgCode()  <<
        "}; "
        "eta: "             << eta(mcTrack, v)        << "; " <<
        "barcode: "         << barcode                << "; " <<
        "nHits: "           << trackIdToNhits.at(trackId);
    if (printReco) {
      std::string isReco;
      if (trackIdToRecoMap.find(trackId) == trackIdToRecoMap.end()) {
        isReco = "key-not-found";
      } else {
        isReco = trackIdToRecoMap.at(trackId) ? "1" : "0";
      }
      std::cout << "; " <<
          "isReco: "    << isReco;
    }
    std::cout << std::endl;
  }
}
